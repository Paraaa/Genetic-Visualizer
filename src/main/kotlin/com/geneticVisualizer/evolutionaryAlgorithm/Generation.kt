package com.geneticVisualizer.evolutionaryAlgorithm

import com.geneticVisualizer.evolutionaryAlgorithm.genome.GenomeStrategy
import com.geneticVisualizer.evolutionaryAlgorithm.optimizationProblem.OptimizationProblemStrategy
import mu.KotlinLogging
import kotlin.math.abs

/**
 * This class stores all information about one generation calculated by [EvolutionaryAlgorithm]
 * @author Andrej Schwanke
 */
class Generation {
    private val LOG = KotlinLogging.logger {}

    /**
     * Generation number
     */
    var number: Int = 0

    /**
     * best fitness in this generation
     */
    var bestFitness: Double = 0.0
    /**
     * worst fitness in this generation
     */
    var worstFitness: Double = 0.0
    /**
     * average fitness in this generation
     */
    var averageFitness: Double = 0.0

    /**
     * Variable to store the coordinates of the best genome in this generation
     */
    var bestGenomeCoordinate: Pair<Double,Double> = Pair(0.0,0.0)
    /**
     * Variable to store the output of the function with the best coordinates as input
     */
    var currentSolution: Double = 0.0

    /**
     * List of genomes of the previous population
     */
    var previousPopulation: MutableList<GenomeStrategy> = mutableListOf()
    /**
     * List of genomes which represent the parent elite
     */
    var parentElite: MutableList<GenomeStrategy> = mutableListOf()
    /**
     * List of genomes which represent the parent population
     */
    var parentPopulation: MutableList<GenomeStrategy> = mutableListOf()
    /**
     * List of genomes which represent the crossover population generated by the parents
     */
    var crossoverPopulation: MutableList<GenomeStrategy> = mutableListOf()
    /**
     * List of genomes which represent the population without the mutated population. This is needed
     * to differentiate the mutated children from the crossover children and parent in the visualisation.
     */
    var populationWithoutMutatedChildren: MutableList<GenomeStrategy> = mutableListOf()
    /**
     * List of genomes which represent the mutated population
     */
    var mutatedPopulation: MutableList<GenomeStrategy> = mutableListOf()
    /**
     * List of genomes which represent the survivor elite
     */
    var survivorElite: MutableList<GenomeStrategy> = mutableListOf()
    /**
     * List of genomes which represent the survivor population
     */
    var survivorPopulation: MutableList<GenomeStrategy> = mutableListOf()
    /**
     * This function fill the [worstFitness], [bestFitness], [averageFitness]
     * and [bestGenomeCoordinate] with the information.
     */
    fun calcStatistics(optimizationProblem: OptimizationProblemStrategy){
        if(survivorPopulation.isEmpty()) return
        worstFitness = (survivorPopulation.minOf { genome -> genome.fitness })
        LOG.debug { "Worst fitness is: $worstFitness" }
        bestFitness  = (survivorPopulation.maxOf { genome -> genome.fitness })
        LOG.debug { "Best fitness is: $bestFitness" }
        averageFitness = (survivorPopulation.sumOf { genome -> genome.fitness }/survivorPopulation.size)
        LOG.debug { "Average fitness is: $averageFitness" }

        survivorPopulation.sortByDescending { genome -> genome.fitness }
        var xCord = survivorPopulation[0].X()/optimizationProblem.scale
        var yCord = survivorPopulation[0].Y()/optimizationProblem.scale
        bestGenomeCoordinate = Pair(xCord, yCord)
        currentSolution = optimizationProblem.calculate(survivorPopulation[0].X(),survivorPopulation[0].Y())
        survivorPopulation.shuffle()
    }


}